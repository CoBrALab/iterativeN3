#!/bin/bash
#
# ARG_HELP([iterativeN3 inhomogeneity correction])
# ARG_OPTIONAL_BOOLEAN([standalone],[],[Save secondary outputs during processing],[on])
# ARG_OPTIONAL_SINGLE([distance],[],[Initial distance for correction],[400])
# ARG_OPTIONAL_SINGLE([levels],[],[Levels of correction with distance halving],[4])
# ARG_OPTIONAL_SINGLE([cycles],[],[Cycles of correction at each level],[3])
# ARG_OPTIONAL_SINGLE([iters],[],[Iterations of correction for each cycle],[25])
# ARG_OPTIONAL_SINGLE([lambda],[],[Spline regularization value],[2e-6])
# ARG_OPTIONAL_SINGLE([fwhm],[],[Intensity histogram smoothing fwhm],[0.1])
# ARG_OPTIONAL_SINGLE([stop],[],[Stopping criterion for N3],[1e-5])
# ARG_OPTIONAL_SINGLE([isostep],[],[Isotropic resampling resolution in mm for N3],[4])
# ARG_OPTIONAL_BOOLEAN([vessels],[],[Attempt to detect and exclude blood vessels],[off])
# ARG_OPTIONAL_SINGLE([lsq6-resample-type],[],[(Standalone) Type of resampling lsq6(rigid) output files undergo, can be "coordinates", "none", or a floating point value for the isotropic resolution in mni_icbm152_t1_tal_nlin_sym_09c space],[none])
# ARG_OPTIONAL_SINGLE([prior-config],[],[Config file to use for models and priors],[mni_icbm152_nlin_sym_09c.cfg])
# ARG_OPTIONAL_BOOLEAN([fast-nlin],[],[Perform fast non-linear registration using Mattes similarity],[off])
# ARG_OPTIONAL_BOOLEAN([save-nlin],[],[Save the non-linear transformation to the model, implies --no-fast-nlin])
# ARG_OPTIONAL_BOOLEAN([clobber],[c],[Overwrite files that already exist])
# ARG_OPTIONAL_BOOLEAN([verbose],[v],[Run commands verbosely],[on])
# ARG_OPTIONAL_BOOLEAN([debug],[d],[Show all internal commands and logic for debug],[])
# ARG_POSITIONAL_SINGLE([input],[Input MINC file])
# ARG_POSITIONAL_SINGLE([output],[Output MINC File])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die() {
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}

begins_with_short_option() {
  local first_option all_short_options='hcvd'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_standalone="on"
_arg_distance="400"
_arg_levels="4"
_arg_cycles="3"
_arg_iters="25"
_arg_lambda="2e-6"
_arg_fwhm="0.1"
_arg_stop="1e-5"
_arg_isostep="4"
_arg_vessels="off"
_arg_lsq6_resample_type="none"
_arg_prior_config="mni_icbm152_nlin_sym_09c.cfg"
_arg_fast_nlin="off"
_arg_save_nlin="off"
_arg_clobber="off"
_arg_verbose="on"
_arg_debug="off"

print_help() {
  printf '%s\n' "iterativeN3 inhomogeneity correction"
  printf 'Usage: %s [-h|--help] [--(no-)standalone] [--distance <arg>] [--levels <arg>] [--cycles <arg>] [--iters <arg>] [--lambda <arg>] [--fwhm <arg>] [--stop <arg>] [--isostep <arg>] [--(no-)vessels] [--lsq6-resample-type <arg>] [--prior-config <arg>] [--(no-)fast-nlin] [--(no-)save-nlin] [-c|--(no-)clobber] [-v|--(no-)verbose] [-d|--(no-)debug] <input> <output>\n' "$0"
  printf '\t%s\n' "<input>: Input MINC file"
  printf '\t%s\n' "<output>: Output MINC File"
  printf '\t%s\n' "-h, --help: Prints help"
  printf '\t%s\n' "--standalone, --no-standalone: Save secondary outputs during processing (on by default)"
  printf '\t%s\n' "--distance: Initial distance for correction (default: '400')"
  printf '\t%s\n' "--levels: Levels of correction with distance halving (default: '4')"
  printf '\t%s\n' "--cycles: Cycles of correction at each level (default: '3')"
  printf '\t%s\n' "--iters: Iterations of correction for each cycle (default: '25')"
  printf '\t%s\n' "--lambda: Spline regularization value (default: '2e-6')"
  printf '\t%s\n' "--fwhm: Intensity histogram smoothing fwhm (default: '0.1')"
  printf '\t%s\n' "--stop: Stopping criterion for N3 (default: '1e-5')"
  printf '\t%s\n' "--isostep: Isotropic resampling resolution in mm for N3 (default: '4')"
  printf '\t%s\n' "--vessels, --no-vessels: Attempt to detect and exclude blood vessels (off by default)"
  printf '\t%s\n' "--lsq6-resample-type: (Standalone) Type of resampling lsq6(rigid) output files undergo, can be \"coordinates\", \"none\", or a floating point value for the isotropic resolution in mni_icbm152_t1_tal_nlin_sym_09c space (default: 'none')"
  printf '\t%s\n' "--prior-config: Config file to use for models and priors (default: 'mni_icbm152_nlin_sym_09c.cfg')"
  printf '\t%s\n' "--fast-nlin, --no-fast-nlin: Perform fast non-linear registration using Mattes similarity (off by default)"
  printf '\t%s\n' "--save-nlin, --no-save-nlin: Save the non-linear transformation to the model, implies --no-fast-nlin (off by default)"
  printf '\t%s\n' "-c, --clobber, --no-clobber: Overwrite files that already exist (off by default)"
  printf '\t%s\n' "-v, --verbose, --no-verbose: Run commands verbosely (on by default)"
  printf '\t%s\n' "-d, --debug, --no-debug: Show all internal commands and logic for debug (off by default)"
}

parse_commandline() {
  _positionals_count=0
  while test $# -gt 0; do
    _key="$1"
    case "$_key" in
      -h | --help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      --no-standalone | --standalone)
        _arg_standalone="on"
        test "${1:0:5}" = "--no-" && _arg_standalone="off"
        ;;
      --distance)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_distance="$2"
        shift
        ;;
      --distance=*)
        _arg_distance="${_key##--distance=}"
        ;;
      --levels)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_levels="$2"
        shift
        ;;
      --levels=*)
        _arg_levels="${_key##--levels=}"
        ;;
      --cycles)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_cycles="$2"
        shift
        ;;
      --cycles=*)
        _arg_cycles="${_key##--cycles=}"
        ;;
      --iters)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_iters="$2"
        shift
        ;;
      --iters=*)
        _arg_iters="${_key##--iters=}"
        ;;
      --lambda)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_lambda="$2"
        shift
        ;;
      --lambda=*)
        _arg_lambda="${_key##--lambda=}"
        ;;
      --fwhm)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_fwhm="$2"
        shift
        ;;
      --fwhm=*)
        _arg_fwhm="${_key##--fwhm=}"
        ;;
      --stop)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_stop="$2"
        shift
        ;;
      --stop=*)
        _arg_stop="${_key##--stop=}"
        ;;
      --isostep)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_isostep="$2"
        shift
        ;;
      --isostep=*)
        _arg_isostep="${_key##--isostep=}"
        ;;
      --no-vessels | --vessels)
        _arg_vessels="on"
        test "${1:0:5}" = "--no-" && _arg_vessels="off"
        ;;
      --lsq6-resample-type)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_lsq6_resample_type="$2"
        shift
        ;;
      --lsq6-resample-type=*)
        _arg_lsq6_resample_type="${_key##--lsq6-resample-type=}"
        ;;
      --prior-config)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_prior_config="$2"
        shift
        ;;
      --prior-config=*)
        _arg_prior_config="${_key##--prior-config=}"
        ;;
      --no-fast-nlin | --fast-nlin)
        _arg_fast_nlin="on"
        test "${1:0:5}" = "--no-" && _arg_fast_nlin="off"
        ;;
      --no-save-nlin | --save-nlin)
        _arg_save_nlin="on"
        test "${1:0:5}" = "--no-" && _arg_save_nlin="off"
        ;;
      -c | --no-clobber | --clobber)
        _arg_clobber="on"
        test "${1:0:5}" = "--no-" && _arg_clobber="off"
        ;;
      -c*)
        _arg_clobber="on"
        _next="${_key##-c}"
        if test -n "$_next" -a "$_next" != "$_key"; then
          { begins_with_short_option "$_next" && shift && set -- "-c" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -v | --no-verbose | --verbose)
        _arg_verbose="on"
        test "${1:0:5}" = "--no-" && _arg_verbose="off"
        ;;
      -v*)
        _arg_verbose="on"
        _next="${_key##-v}"
        if test -n "$_next" -a "$_next" != "$_key"; then
          { begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -d | --no-debug | --debug)
        _arg_debug="on"
        test "${1:0:5}" = "--no-" && _arg_debug="off"
        ;;
      -d*)
        _arg_debug="on"
        _next="${_key##-d}"
        if test -n "$_next" -a "$_next" != "$_key"; then
          { begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      *)
        _last_positional="$1"
        _positionals+=("$_last_positional")
        _positionals_count=$((_positionals_count + 1))
        ;;
    esac
    shift
  done
}

handle_passed_args_count() {
  local _required_args_string="'input' and 'output'"
  test "${_positionals_count}" -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}

assign_positional_args() {
  local _positional_name _shift_for=$1
  _positional_names="_arg_input _arg_output "

  shift "$_shift_for"
  for _positional_name in ${_positional_names}; do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

set -uo pipefail
set -eE -o functrace

### BASH HELPER FUNCTIONS ###
# Stolen from https://github.com/kvz/bash3boilerplate

# Set magic variables for current file, directory, os, etc.
__dir="$(cd "$(dirname "${BASH_SOURCE[${__b3bp_tmp_source_idx:-0}]}")" && pwd)"
__file="${__dir}/$(basename "${BASH_SOURCE[${__b3bp_tmp_source_idx:-0}]}")"
__base="$(basename "${__file}" .sh)"
# shellcheck disable=SC2034,SC2015
__invocation="$(printf %q "${__file}")$( (($#)) && printf ' %q' "$@" || true)"

if [[ ${_arg_debug} == "on" ]]; then
  LOG_LEVEL=7
  set -x
else
  LOG_LEVEL=6
fi

function __b3bp_log() {
  local log_level="${1}"
  shift

  # shellcheck disable=SC2034
  local color_debug="\\x1b[35m" #]
  # shellcheck disable=SC2034
  local color_info="\\x1b[32m" #]
  # shellcheck disable=SC2034
  local color_notice="\\x1b[34m" #]
  # shellcheck disable=SC2034
  local color_warning="\\x1b[33m" #]
  # shellcheck disable=SC2034
  local color_error="\\x1b[31m" #]
  # shellcheck disable=SC2034
  local color_critical="\\x1b[1;31m" #]
  # shellcheck disable=SC2034
  local color_alert="\\x1b[1;37;41m" #]
  # shellcheck disable=SC2034
  local color_failure="\\x1b[1;4;5;37;41m" #]

  local colorvar="color_${log_level}"

  local color="${!colorvar:-${color_error}}"
  local color_reset="\\x1b[0m" #]

  if [[ "${NO_COLOR:-}" = "true" ]] || { [[ "${TERM:-}" != "xterm"* ]] && [[ "${TERM:-}" != "screen"* ]]; } || [[ ! -t 2 ]]; then
    if [[ "${NO_COLOR:-}" != "false" ]]; then
      # Don't use colors on pipes or non-recognized terminals
      color=""
      color_reset=""
    fi
  fi

  # all remaining arguments are to be printed
  local log_line=""

  while IFS=$'\n' read -r log_line; do
    echo -e "$(date -u +"%Y-%m-%d %H:%M:%S UTC") ${color}$(printf "[%9s]" "${log_level}")${color_reset} ${log_line}" 1>&2
  done <<<"${@:-}"
}

function failure() {
  __b3bp_log failure "${@}"
  exit 1
}
function alert() {
  [[ "${LOG_LEVEL:-0}" -ge 1 ]] && __b3bp_log alert "${@}"
  true
}
function critical() {
  [[ "${LOG_LEVEL:-0}" -ge 2 ]] && __b3bp_log critical "${@}"
  true
}
function error() {
  [[ "${LOG_LEVEL:-0}" -ge 3 ]] && __b3bp_log error "${@}"
  true
}
function warning() {
  [[ "${LOG_LEVEL:-0}" -ge 4 ]] && __b3bp_log warning "${@}"
  true
}
function notice() {
  [[ "${LOG_LEVEL:-0}" -ge 5 ]] && __b3bp_log notice "${@}"
  true
}
function info() {
  [[ "${LOG_LEVEL:-0}" -ge 6 ]] && __b3bp_log info "${@}"
  true
}
function debug() {
  [[ "${LOG_LEVEL:-0}" -ge 7 ]] && __b3bp_log debug "${@}"
  true
}

# Add handler for failure to show where things went wrong
failure_handler() {
  local lineno=$2
  local fn=$3
  local exitstatus=$4
  local msg=$5
  local lineno_fns=${1% 0}
  if [[ "$lineno_fns" != "0" ]]; then
    lineno="${lineno} ${lineno_fns}"
  fi
  echo "${BASH_SOURCE[1]}:${fn}[${lineno}] Failed with status ${exitstatus}: $msg"
}
trap 'failure_handler "${BASH_LINENO[*]}" "$LINENO" "${FUNCNAME[*]:-script}" "$?" "$BASH_COMMAND"' ERR

function run_smart {
  # Function runs the command it wraps if the file does not exist
  if [[ ! -s "$1" ]]; then
    "$2"
  fi
}

BEASTLIBRARY_DIR="${QUARANTINE_PATH}/resources/BEaST_libraries/combined"
RESAMPLEMODEL="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c.mnc"
RESAMPLEMASK="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c_mask.mnc"
RESAMPLEOUTLINE="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c_outline.mnc"

# Load configuration
if [[ -s ${_arg_prior_config} ]]; then
  source ${_arg_prior_config}
elif [[ -s ${__dir}/configs/${_arg_prior_config} ]]; then
  source ${__dir}/configs/${_arg_prior_config}
else
  failure "${_arg_prior_config} not found"
fi

#Calculator for maths
calc() { awk "BEGIN{ print $* }"; }

function make_qc() {
  # Generate a standardized view of the final correct brain in MNI space, with classification overlayed
  # Create animated version if img2webp is available
  mkdir -p ${tmpdir}/qc

  # Resample into MNI space for all the inputs for standard visualization
  # Classification
  antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} -t ${tmpdir}/${n}/mni0_GenericAffine.xfm \
    -i ${tmpdir}/${n}/classify.mnc -o ${tmpdir}/qc/classify.mnc -r ${RESAMPLEMODEL} -n GenericLabel

  # Masks
  antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} -t ${tmpdir}/${n}/mni0_GenericAffine.xfm \
    -i ${tmpdir}/mergedmask.mnc -o ${tmpdir}/qc/mask.mnc -r ${RESAMPLEMODEL} -n GenericLabel

  # Final Corrected Image
  antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} -t ${tmpdir}/${n}/mni0_GenericAffine.xfm \
    -i ${tmpdir}/denoise_corrected.mnc -o ${tmpdir}/qc/corrected.mnc -r ${RESAMPLEMODEL} -n BSpline[5]

  # Final Corrected Image with nlin
  antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} -t ${tmpdir}/${n}/mni1_NL.xfm -t ${tmpdir}/${n}/mni0_GenericAffine.xfm \
    -i ${tmpdir}/denoise_corrected.mnc -o ${tmpdir}/qc/corrected_nlin.mnc -r ${RESAMPLEMODEL} -n BSpline[5]

  # Original input image
  antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} -t ${tmpdir}/${n}/mni0_GenericAffine.xfm \
    -i ${tmpdir}/origqcref.mnc -o ${tmpdir}/qc/orig.mnc -r ${RESAMPLEMODEL} -n BSpline[5]

  # Resample REGISTRATIONOUTLINE and use it if defined
  if [[ -s ${REGISTRATIONOUTLINE:-} ]]; then
    antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} \
      -i ${REGISTRATIONOUTLINE} -o ${tmpdir}/qc/outline.mnc -r ${RESAMPLEMODEL} -n GenericLabel
    RESAMPLEOUTLINE=${tmpdir}/qc/outline.mnc
  fi

  mincmath -clobber -quiet ${N4_VERBOSE:+-verbose} -clamp -const2 0 65535 ${tmpdir}/qc/corrected.mnc ${tmpdir}/qc/corrected.clamp.mnc
  mv -f ${tmpdir}/qc/corrected.clamp.mnc ${tmpdir}/qc/corrected.mnc
  mincmath -clobber -quiet ${N4_VERBOSE:+-verbose} -clamp -const2 0 65535 ${tmpdir}/qc/orig.mnc ${tmpdir}/qc/orig.clamp.mnc
  mv -f ${tmpdir}/qc/orig.clamp.mnc ${tmpdir}/qc/orig.mnc
  mincmath -clobber -quiet ${N4_VERBOSE:+-verbose} -clamp -const2 0 65535 ${tmpdir}/qc/corrected_nlin.mnc ${tmpdir}/qc/corrected.clamp.mnc
  mv -f ${tmpdir}/qc/corrected.clamp.mnc ${tmpdir}/qc/corrected_nlin.mnc

  # Create the bounding box for create_verify_image
  mincresample -clobber -quiet ${N4_VERBOSE:+-verbose} $(mincbbox -mincresample ${tmpdir}/qc/classify.mnc) ${tmpdir}/qc/classify.mnc ${tmpdir}/qc/label-crop.mnc
  minccalc -quiet ${N4_VERBOSE:+-verbose} -unsigned -byte -expression '1' ${tmpdir}/qc/label-crop.mnc ${tmpdir}/qc/bounding.mnc

  # Create Building Block Slices
  for slicedir in t s c; do
    # Corrected image in gray
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_corrected_gray.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected.mnc color:gray:0:65535

    # Corrected image in spectral
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_corrected_spect.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected.mnc color:spect:0:65535

    # Original image in gray
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_orig_gray.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/orig.mnc color:gray:0:65535

    # Original image in spectral
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_orig_spect.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/orig.mnc color:spect:0:65535

    # Corrected image with classification
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_classified.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected.mnc color:gray:0:65535 \
      volume_overlay:${tmpdir}/qc/classify.mnc:0.4

    # Corrected image with mask
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_mask.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected.mnc color:gray:0:65535 \
      volume_overlay:${tmpdir}/qc/mask.mnc:0.4:red

    # Corrected image with outline
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_outline.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected.mnc color:gray:0:65535 \
      volume_overlay:${RESAMPLEOUTLINE}:0.7:red

    # Corrected image with nlin outline
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_nlin_outline.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected_nlin.mnc color:gray:0:65535 \
      volume_overlay:${RESAMPLEOUTLINE}:0.7:red
  done

  convert -background black -strip -append \
    -interlace Plane -sampling-factor 4:2:0 -quality "85%" \
    ${tmpdir}/qc/c_orig_spect.rgb \
    ${tmpdir}/qc/c_corrected_spect.rgb \
    ${tmpdir}/qc/s_orig_spect.rgb \
    ${tmpdir}/qc/s_corrected_spect.rgb \
    ${tmpdir}/qc/t_orig_spect.rgb \
    ${tmpdir}/qc/t_corrected_spect.rgb \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.bias.jpg

  convert -background black -strip -append \
    -interlace Plane -sampling-factor 4:2:0 -quality "85%" \
    ${tmpdir}/qc/c_mask.rgb \
    ${tmpdir}/qc/c_classified.rgb \
    ${tmpdir}/qc/s_mask.rgb \
    ${tmpdir}/qc/s_classified.rgb \
    ${tmpdir}/qc/t_mask.rgb \
    ${tmpdir}/qc/t_classified.rgb \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.mask.classified.jpg

  convert -background black -strip -append \
    -interlace Plane -sampling-factor 4:2:0 -quality "85%" \
    ${tmpdir}/qc/c_outline.rgb \
    ${tmpdir}/qc/c_nlin_outline.rgb \
    ${tmpdir}/qc/s_outline.rgb \
    ${tmpdir}/qc/s_nlin_outline.rgb \
    ${tmpdir}/qc/t_outline.rgb \
    ${tmpdir}/qc/t_nlin_outline.rgb \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.registration.jpg

  # If webp software is available animate a before/after image
  if command -v img2webp; then
    img2webp -d 1000 -lossy -min_size \
      $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.bias.jpg \
      $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.mask.classified.jpg \
      $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.registration.jpg \
      -o $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.webp || true
  fi
}

isotropize() {
  # Need smoothing for downsampling to avoid aliasing
  # Ideas stolen from https://discourse.itk.org/t/resampling-to-isotropic-signal-processing-theory/1403
  inputres=$(python -c "print('\n'.join([str(abs(x)) for x in [float(x) for x in \"$(PrintHeader ${1} 1)\".split(\"x\")]]))")
  blurs=""

  for dim in ${inputres}; do
    if [[ $(python -c "print(${dim}>(${_arg_isostep}-1e-6))") == True ]]; then
      #Special casing for zero/negative blurs
      blurs+=1e-12x
    else
      blurs+=$(python -c "import math; print(math.sqrt((${_arg_isostep}**2.0 - ${dim}**2.0)/(2.0*math.sqrt(2.0*math.log(2.0)))**2.0))")x
    fi
  done

  mincmath -mult ${tmpdir}/vessels.mnc ${1} ${tmpdir}/${n}/presmooth_novessels.mnc

  SmoothImage 3 ${tmpdir}/${n}/presmooth_novessels.mnc "${blurs%?}" ${tmpdir}/${n}/smoothed.mnc 1 0
  ResampleImage 3 ${tmpdir}/${n}/smoothed.mnc ${tmpdir}/${n}/isotropized.mnc ${_arg_isostep}x${_arg_isostep}x${_arg_isostep} 0 4

  mincmath -quiet -clamp -const2 0 65535 ${tmpdir}/${n}/isotropized.mnc ${tmpdir}/${n}/downsample.mnc

}

#Iterative multi-scale N3 implementation
do_N3() {
  # This code does cycles of N3 at a given scale, and then halves the scale and repeats until the limit is reached
  # Input images are downsampled before N3
  isotropize ${n3input}
  n3input=${tmpdir}/${n}/downsample.mnc
  minccalc -unsigned -byte -expression 'A[0]>1?1:0' ${tmpdir}/${n}/downsample.mnc ${tmpdir}/${n}/nonzero.mnc
  antsApplyTransforms -d 3 -i ${tmpdir}/${n}/weight.mnc -o ${tmpdir}/${n}/tmpweight.mnc -r ${n3input} -n GenericLabel --verbose
  ImageMath 3 ${tmpdir}/${n}/tmpweight.mnc m ${tmpdir}/${n}/tmpweight.mnc ${tmpdir}/${n}/nonzero.mnc
  distance=${_arg_distance}
  j=0
  while ((j < _arg_levels)); do
    i=0
    while ((i < _arg_cycles)); do
      nu_correct -clobber -normalize_field \
        -stop ${_arg_stop} -distance ${distance} -iterations ${_arg_iters} -fwhm ${_arg_fwhm} -shrink 1 -lambda ${_arg_lambda} \
        -mask ${tmpdir}/${n}/tmpweight.mnc ${n3input} ${tmpdir}/${n}/corrected_${distance}_${i}.mnc

      evaluate_field -unsigned -double -clobber -like ${n3input} ${tmpdir}/${n}/corrected_${distance}_${i}.imp ${tmpdir}/${n}/corrected_${distance}_${i}_field.mnc

      biasmean=$(mincstats -mean -quiet -mask ${tmpdir}/${n}/tmpweight.mnc -mask_binvalue 1 ${tmpdir}/${n}/corrected_${distance}_${i}_field.mnc)
      origmean=$(mincstats -mean -quiet -mask ${tmpdir}/${n}/tmpweight.mnc -mask_binvalue 1 ${n3input})

      minccalc -clobber -unsigned -short \
        -expression "clamp((A[0]/${origmean})/(A[1]/${biasmean})*32767,0,65535)" \
        ${n3input} ${tmpdir}/${n}/corrected_${distance}_${i}_field.mnc ${tmpdir}/${n}/corrected_${distance}_${i}.mnc -clobber

      n3input=${tmpdir}/${n}/corrected_${distance}_${i}.mnc

      ((++i))
    done
    distance=$(calc "${distance} / 2")
    ((++j))
  done

  for file in ${tmpdir}/${n}/*imp; do
    echo evaluate_field -unsigned -double -clobber -like ${tmpdir}/input.mnc ${file} ${tmpdir}/${n}/$(basename $file .imp)_field.mnc
  done | parallel
}

make_outlier_map() {
  outlier_input=$1
  mask_input=$2
  outlier_output=$3

  median=$(mincstats -mask ${mask_input} -mask_binvalue 1 -median -quiet ${outlier_input})

  minccalc -clobber \
    -expression "abs(A[0]-${median})" \
    ${outlier_input} ${tmpdir}/${n}/madmap.mnc

  mad=$(mincstats -mask ${mask_input} -mask_binvalue 1 -median -quiet ${tmpdir}/${n}/madmap.mnc)

  minccalc -expression "((0.6745*(A[0] - ${median}))/${mad})>3.5?0:1" \
    ${outlier_input} ${outlier_output}
}

tmpdir=$(mktemp -d)

#Setup exit trap for cleanup, don't do if debug
function finish() {
  if [[ ${_arg_debug} == "off" ]]; then
    rm -rf "${tmpdir}"
  else
    warning "Debug enabled, temporary files at ${tmpdir} have not been cleaned up"
  fi
}
trap finish EXIT

#Add handler for failure to show where things went wrong
failure_handler() {
  local lineno=$1
  local msg=$2
  echo "Failed at $lineno: $msg"
}
trap 'failure_handler ${LINENO} "$BASH_COMMAND"' ERR

function classify_to_mask() {
  # Convert classify image into a mask
  # Mostly a clone of the supersteps of antsBrainExtraction
  ResampleImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/classify1mm.mnc 1x1x1 0 1
  ThresholdImage 3 ${tmpdir}/${n}/classify1mm.mnc ${tmpdir}/${n}/gm.mnc 2 2 1 0
  ThresholdImage 3 ${tmpdir}/${n}/classify1mm.mnc ${tmpdir}/${n}/wm.mnc 3 3 1 0
  if [[ -s ${tmpdir}/${n}/posterior4.mnc ]]; then
    ThresholdImage 3 ${tmpdir}/${n}/classify1mm.mnc ${tmpdir}/${n}/deepgm.mnc 4 4 1 0
    ImageMath 3 ${tmpdir}/${n}/gm.mnc addtozero ${tmpdir}/${n}/deepgm.mnc ${tmpdir}/${n}/gm.mnc
  fi

  ImageMath 3 ${tmpdir}/${n}/gm.mnc GetLargestComponent ${tmpdir}/${n}/gm.mnc
  ImageMath 3 ${tmpdir}/${n}/wm.mnc GetLargestComponent ${tmpdir}/${n}/wm.mnc

  ImageMath 3 ${tmpdir}/${n}/gm.mnc FillHoles ${tmpdir}/${n}/gm.mnc 2

  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc addtozero ${tmpdir}/${n}/gm.mnc ${tmpdir}/${n}/wm.mnc

  iMath 3 ${tmpdir}/${n}/classifymask.mnc ME ${tmpdir}/${n}/classifymask.mnc 1 1 ball 1
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc GetLargestComponent ${tmpdir}/${n}/classifymask.mnc
  iMath 3 ${tmpdir}/${n}/classifymask.mnc MD ${tmpdir}/${n}/classifymask.mnc 2 1 ball 1
  ResampleImage 3 ${tmpdir}/${n}/nlin_mnimask.mnc ${tmpdir}/${n}/nlin_mnimask1mm.mnc 1x1x1 0 1
  iMath 3 ${tmpdir}/${n}/nlin_mnimask1mm_E.mnc ME ${tmpdir}/${n}/nlin_mnimask1mm.mnc 10 1 ball 1
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc addtozero ${tmpdir}/${n}/classifymask.mnc ${tmpdir}/${n}/nlin_mnimask1mm.mnc
  ImageMath 3 ${tmpdir}/${n}/classifymask.mnc FillHoles ${tmpdir}/${n}/classifymask.mnc 2
  antsApplyTransforms -d 3 -i ${tmpdir}/${n}/classifymask.mnc -o ${tmpdir}/classifymask.mnc -r ${tmpdir}/${n}/classify.mnc -n GenericLabel --verbose
}

# Output checking
if [[ "${_arg_clobber}" == "off" ]]; then
  for file in ${_arg_output} \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).beastmask.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).classifymask.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlinmask.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).mergedmask.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).classify.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).posterior1.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).posterior2.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).posterior3.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).posterior4.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).denoise.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).affine_to_model.xfm \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_to_model.xfm \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_from_model.xfm \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).ICV.xfm \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.webp \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.mask.classified.jpg \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.bias.jpg \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.registration.jpg \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.xfm \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mergedmask.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.classify.mnc; do
    if [[ -s "${file}" ]]; then
      failure "File ${file} already exists and --clobber not specified!"
    fi
  done
fi

# Save-nlin and fast mangling
if [[ ${_arg_save_nlin} == "on" || ${_arg_fast_nlin} == "off" ]]; then
  _arg_fast_nlin=""
else
  _arg_fast_nlin="--fast"
fi

input=${_arg_input}

# Calulate a scaling factor for mm from isostep
dx=$(mincinfo -attvalue xspace:step ${input})
dy=$(mincinfo -attvalue yspace:step ${input})
dz=$(mincinfo -attvalue zspace:step ${input})
shrink=$(python -c "print(${_arg_isostep} / ( ( abs(${dx}) + abs(${dy}) + abs(${dz}) ) / 3.0 ))")

# Change the slicing direction to be the same as what ITK outputs by default
mincreshape -dimorder zspace,yspace,xspace +direction ${input} ${tmpdir}/reshape1.mnc
mincreshape -dimorder zspace,yspace,xspace +direction ${tmpdir}/reshape1.mnc ${tmpdir}/reshape2.mnc
rm -f ${tmpdir}/reshape1.mnc

# Store the direction cosine transform because we're going to zero out the file
dircos_to_xfm ${tmpdir}/reshape2.mnc ${tmpdir}/transform_to_input.xfm

#Square up direction cosines
minc_modify_header -dinsert xspace:direction_cosines=1,0,0 ${tmpdir}/reshape2.mnc
minc_modify_header -dinsert yspace:direction_cosines=0,1,0 ${tmpdir}/reshape2.mnc
minc_modify_header -dinsert zspace:direction_cosines=0,0,1 ${tmpdir}/reshape2.mnc

input=${tmpdir}/reshape2.mnc

mincnorm -noclamp -cutoff 0.001 ${input} ${tmpdir}/originput.mnc
mincmath -clamp -const2 0 inf ${tmpdir}/originput.mnc ${tmpdir}/norm.mnc
mv -f ${tmpdir}/norm.mnc ${tmpdir}/originput.mnc

# Clamp range to avoid negative numbers, rescale to 0-65535
mincnorm -noclamp -short -out_floor 0 -out_ceil 65535 ${input} ${tmpdir}/input.mnc
mincmath -clamp -const2 0 inf ${tmpdir}/input.mnc ${tmpdir}/norm.mnc
mv -f ${tmpdir}/norm.mnc ${tmpdir}/input.mnc

cp -f ${tmpdir}/input.mnc ${tmpdir}/origqcref.mnc

# Pad image for processing
volpad -noauto -distance 20 ${tmpdir}/input.mnc ${tmpdir}/pad.mnc
mv -f ${tmpdir}/pad.mnc ${tmpdir}/input.mnc

# Begin preprocessing
n=0
mkdir -p ${tmpdir}/${n}

minc_anlm --clobber --mt $(nproc) ${tmpdir}/input.mnc ${tmpdir}/${n}/denoise.mnc

if [[ ${_arg_vessels} == "on" ]]; then
  # Masking of blood vessels
  itk_vesselness --clobber --scales 8 --rescale ${tmpdir}/input.mnc ${tmpdir}/vessels.mnc
  ThresholdImage 3 ${tmpdir}/vessels.mnc ${tmpdir}/vessels.mnc 35 Inf 0 1
else
  minccalc -unsigned -byte -expression '1' ${tmpdir}/input.mnc ${tmpdir}/vessels.mnc
fi

# Round 1, Otsu mask of foreground
ThresholdImage 3 ${tmpdir}/input.mnc ${tmpdir}/${n}/bgmask.mnc 1 Inf 1 0
cp -f ${tmpdir}/${n}/bgmask.mnc ${tmpdir}/bgmask.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/bgmask.mnc ${tmpdir}/vessels.mnc
ThresholdImage 3 ${tmpdir}/${n}/denoise.mnc ${tmpdir}/${n}/weight.mnc Otsu 4 ${tmpdir}/${n}/weight.mnc
ThresholdImage 3 ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc 2 Inf 1 0

iMath 3 ${tmpdir}/${n}/fgmask.mnc MC ${tmpdir}/${n}/weight.mnc 10 1 ball 1
ImageMath 3 ${tmpdir}/${n}/fgmask.mnc FillHoles ${tmpdir}/${n}/fgmask.mnc 2
ImageMath 3 ${tmpdir}/${n}/fgmask.mnc GetLargestComponent ${tmpdir}/${n}/fgmask.mnc

ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/vessels.mnc
minccalc -unsigned -byte -expression 'A[0]>1?1:0' ${tmpdir}/input.mnc ${tmpdir}/${n}/nonzero.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/nonzero.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc

make_outlier_map ${tmpdir}/${n}/denoise.mnc ${tmpdir}/${n}/fgmask.mnc ${tmpdir}/${n}/hotmask.mnc

n3input=${tmpdir}/input.mnc

# Initial correction not used for the final outputs but rather just to enable good foreground-background masking
N4BiasFieldCorrection -d 3 --verbose -i ${n3input} \
  -b [ ${_arg_distance} ] -s $(awk -v flt=${shrink} 'BEGIN { printf("%.0f", flt); }') \
  --histogram-sharpening [ 0.1,0.01,200 ] \
  -c [ 300x300x300x300x300,1e-5 ] \
  -x ${tmpdir}/bgmask.mnc -w ${tmpdir}/${n}/weight.mnc \
  -o [ ${tmpdir}/${n}/correct.mnc,${tmpdir}/${n}/bias.mnc ]

biasmean=$(mincstats -mean -quiet -mask ${tmpdir}/${n}/weight.mnc -mask_binvalue 1 ${tmpdir}/${n}/bias.mnc)
origmean=$(mincstats -mean -quiet -mask ${tmpdir}/${n}/weight.mnc -mask_binvalue 1 ${tmpdir}/input.mnc)

minccalc -unsigned -short -expression "clamp((A[0]/${origmean})/(A[1]/${biasmean})*32767,0,65535)" \
  ${tmpdir}/input.mnc ${tmpdir}/${n}/bias.mnc ${tmpdir}/${n}/correct.mnc -clobber

((++n))
mkdir -p ${tmpdir}/${n}

# Redo intensity normalization
antsApplyTransforms -d 3 -i ${tmpdir}/$((n - 1))/fgmask.mnc -r ${input} -o ${tmpdir}/fgmask_orig.mnc -n GenericLabel
mincnorm -clobber -short -noclamp -mask ${tmpdir}/fgmask_orig.mnc -out_floor 0 -out_ceil 65535 ${input} ${tmpdir}/input.mnc
mincmath -clamp -const2 0 inf ${tmpdir}/input.mnc ${tmpdir}/norm.mnc
mv -f ${tmpdir}/norm.mnc ${tmpdir}/input.mnc

volpad -noauto -distance 20 ${tmpdir}/input.mnc ${tmpdir}/pad.mnc
mv -f ${tmpdir}/pad.mnc ${tmpdir}/input.mnc

minc_anlm --clobber --mt $(nproc) ${tmpdir}/$((n - 1))/correct.mnc ${tmpdir}/${n}/denoise.mnc

if [[ ${_arg_vessels} == "on" ]]; then
  # Masking of blood vessels
  itk_vesselness --clobber --scales 8 --rescale ${tmpdir}/$((n - 1))/correct.mnc ${tmpdir}/vessels.mnc
  ThresholdImage 3 ${tmpdir}/vessels.mnc ${tmpdir}/vessels.mnc 35 Inf 0 1
else
  minccalc -clobber -unsigned -byte -expression '1' ${tmpdir}/$((n - 1))/correct.mnc ${tmpdir}/vessels.mnc
fi

# Redo the Otsu mask a second time using the precorrected image
ThresholdImage 3 ${tmpdir}/$((n - 1))/correct.mnc ${tmpdir}/${n}/bgmask.mnc 1 Inf 1 0
cp -f ${tmpdir}/${n}/bgmask.mnc ${tmpdir}/bgmask.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/bgmask.mnc ${tmpdir}/vessels.mnc
ThresholdImage 3 ${tmpdir}/${n}/denoise.mnc ${tmpdir}/${n}/weight.mnc Otsu 4 ${tmpdir}/${n}/weight.mnc
ThresholdImage 3 ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc 2 Inf 1 0
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc
iMath 3 ${tmpdir}/${n}/weight.mnc MC ${tmpdir}/${n}/weight.mnc 10 1 ball 1
ImageMath 3 ${tmpdir}/${n}/weight.mnc FillHoles ${tmpdir}/${n}/weight.mnc 2
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/vessels.mnc
ThresholdImage 3 ${tmpdir}/${n}/denoise.mnc ${tmpdir}/${n}/weight.mnc Otsu 4 ${tmpdir}/${n}/weight.mnc

ThresholdImage 3 ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/fgmask.mnc 2 Inf 1 0
ImageMath 3 ${tmpdir}/${n}/fgmask.mnc GetLargestComponent ${tmpdir}/${n}/fgmask.mnc
iMath 3 ${tmpdir}/${n}/fgmask.mnc MC ${tmpdir}/${n}/fgmask.mnc 10 1 ball 1
ImageMath 3 ${tmpdir}/${n}/fgmask.mnc FillHoles ${tmpdir}/${n}/fgmask.mnc 2

make_outlier_map ${tmpdir}/${n}/denoise.mnc ${tmpdir}/${n}/fgmask.mnc ${tmpdir}/${n}/hotmask.mnc

ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/fgmask.mnc ${tmpdir}/${n}/hotmask.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/vessels.mnc

ThresholdImage 3 ${tmpdir}/${n}/denoise.mnc ${tmpdir}/${n}/weight.mnc Otsu 4 ${tmpdir}/${n}/weight.mnc

ThresholdImage 3 ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc 3 Inf 1 0
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc

minc_anlm --clobber --mt $(nproc) ${tmpdir}/input.mnc ${tmpdir}/input_denoise.mnc

# For the all-data N3, don't fit too tightly
origlevels=${_arg_levels}
_arg_levels=$(calc "${_arg_levels} - 1")

n3input=${tmpdir}/input_denoise.mnc
do_N3

_arg_levels=${origlevels}

mincmath -clobber -unsigned -double -mult ${tmpdir}/${n}/*field.mnc ${tmpdir}/${n}/field_combined.mnc

correct_field ${tmpdir}/${n}/field_combined.mnc ${tmpdir}/${n}/fgmask.mnc ${tmpdir}/${n}/field_combined_correct.mnc
mincmath -clobber -clamp -const2 0.1 1.79769e+308 ${tmpdir}/${n}/field_combined_correct.mnc ${tmpdir}/${n}/field_combined_correct_clamp.mnc

origmean=$(mincstats -mean -quiet -mask ${tmpdir}/${n}/weight.mnc -mask_binvalue 1 ${tmpdir}/input.mnc)
biasmean=$(mincstats -mean -quiet -mask ${tmpdir}/${n}/weight.mnc -mask_binvalue 1 ${tmpdir}/${n}/field_combined_correct_clamp.mnc)

minccalc -unsigned -short -expression "clamp((A[0]/${origmean})/(A[1]/${biasmean})*32767,0,65535)" ${tmpdir}/input.mnc \
  ${tmpdir}/${n}/field_combined_correct_clamp.mnc ${tmpdir}/${n}/correct.mnc -clobber

((++n))
mkdir -p ${tmpdir}/${n}

minc_anlm --clobber --mt $(nproc) ${tmpdir}/$((n - 1))/correct.mnc ${tmpdir}/${n}/denoise.mnc

antsRegistration_affine_SyN.sh --verbose --histogram-matching \
  --skip-nonlinear --fixed-mask ${REGISTRATIONBRAINMASK} \
  ${tmpdir}/${n}/denoise.mnc ${REGISTRATIONMODEL} ${tmpdir}/${n}/mni

minccalc -unsigned -byte -expression '1' ${RESAMPLEMODEL} ${tmpdir}/model_fov.mnc
mincresample -nofill -clobber -labels -near -like ${tmpdir}/input.mnc -transform ${tmpdir}/${n}/mni0_GenericAffine.xfm \
  ${tmpdir}/model_fov.mnc ${tmpdir}/subject_fov.mnc
ImageMath 3 ${tmpdir}/fgmask_fov.mnc m ${tmpdir}/$((n - 1))/fgmask.mnc ${tmpdir}/subject_fov.mnc
cp -f ${tmpdir}/$((n - 1))/fgmask.mnc ${tmpdir}/fgmask.mnc

antsApplyTransforms -d 3 -i ${REGISTRATIONBRAINMASK} \
  -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] \
  -n GenericLabel --verbose -r ${tmpdir}/input.mnc \
  -o ${tmpdir}/${n}/mnimask.mnc

antsRegistration_affine_SyN.sh --clobber --verbose --close --histogram-matching \
  --initial-transform ${tmpdir}/${n}/mni0_GenericAffine.xfm \
  --skip-nonlinear --fixed-mask ${REGISTRATIONBRAINMASK} --moving-mask ${tmpdir}/${n}/mnimask.mnc \
  ${tmpdir}/${n}/denoise.mnc ${REGISTRATIONMODEL} ${tmpdir}/${n}/mni

antsApplyTransforms -d 3 -i ${REGISTRATIONBRAINMASK} \
  -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] \
  -n GenericLabel --verbose -r ${tmpdir}/input.mnc \
  -o ${tmpdir}/${n}/mnimask.mnc

iMath 3 ${tmpdir}/${n}/mnimask.mnc MD ${tmpdir}/${n}/mnimask.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/mnimask.mnc m ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/vessels.mnc
ThresholdImage 3 ${tmpdir}/${n}/denoise.mnc ${tmpdir}/${n}/weight.mnc Otsu 4 ${tmpdir}/${n}/mnimask.mnc
ThresholdImage 3 ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc 2 Inf 1 0
iMath 3 ${tmpdir}/${n}/weight.mnc ME ${tmpdir}/${n}/weight.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc
iMath 3 ${tmpdir}/${n}/weight.mnc MD ${tmpdir}/${n}/weight.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/vessels.mnc

iMath 3 ${tmpdir}/${n}/mnimask.mnc MC ${tmpdir}/${n}/weight.mnc 5 1 ball 1
ImageMath 3 ${tmpdir}/${n}/mnimask.mnc FillHoles ${tmpdir}/${n}/mnimask.mnc 2

ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/mnimask.mnc ${tmpdir}/vessels.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/$((n - 1))/hotmask.mnc
ThresholdImage 3 ${tmpdir}/${n}/denoise.mnc ${tmpdir}/${n}/weight.mnc Kmeans 2 ${tmpdir}/${n}/weight.mnc
ThresholdImage 3 ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/weight.mnc 2 Inf 1 0

make_outlier_map ${tmpdir}/${n}/denoise.mnc ${tmpdir}/fgmask.mnc ${tmpdir}/${n}/hotmask.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/vessels.mnc

n3input=${tmpdir}/${n}/denoise.mnc

do_N3

iMath 3 ${tmpdir}/${n}/correct_mask.mnc MD ${tmpdir}/${n}/mnimask.mnc 2 1 ball 1
ImageMath 3 ${tmpdir}/${n}/correct_mask.mnc FillHoles ${tmpdir}/${n}/correct_mask.mnc 2

mincmath -clobber -unsigned -double -mult ${tmpdir}/${n}/*field.mnc ${tmpdir}/${n}/field_combined.mnc

correct_field ${tmpdir}/${n}/field_combined.mnc ${tmpdir}/${n}/correct_mask.mnc ${tmpdir}/${n}/field_combined_correct.mnc
mincmath -clobber -clamp -const2 0.1 1.79769e+308 ${tmpdir}/${n}/field_combined_correct.mnc ${tmpdir}/${n}/field_combined_correct_clamp.mnc

mincmath -clobber -unsigned -double -mult ${tmpdir}/$((n - 1))/field_combined_correct_clamp.mnc \
  ${tmpdir}/${n}/field_combined_correct_clamp.mnc ${tmpdir}/${n}/field_combined_correct_clamp2.mnc
mv -f ${tmpdir}/${n}/field_combined_correct_clamp2.mnc ${tmpdir}/${n}/field_combined_correct_clamp.mnc

origmean=$(mincstats -mean -quiet -mask ${tmpdir}/${n}/weight.mnc -mask_binvalue 1 ${tmpdir}/input.mnc)
biasmean=$(mincstats -mean -quiet -mask ${tmpdir}/${n}/weight.mnc -mask_binvalue 1 ${tmpdir}/${n}/field_combined_correct_clamp.mnc)

minccalc -unsigned -short -expression "clamp((A[0]/${origmean})/(A[1]/${biasmean})*32767,0,65535)" \
  ${tmpdir}/input.mnc ${tmpdir}/${n}/field_combined_correct_clamp.mnc ${tmpdir}/${n}/correct.mnc -clobber

((++n))
mkdir -p ${tmpdir}/${n}

minc_anlm --clobber --mt $(nproc) ${tmpdir}/$((n - 1))/correct.mnc ${tmpdir}/${n}/denoise.mnc

antsRegistration_affine_SyN.sh --clobber --verbose --close --histogram-matching \
  --initial-transform ${tmpdir}/$((n - 1))/mni0_GenericAffine.xfm \
  --skip-nonlinear \
  --fixed-mask ${REGISTRATIONBRAINMASK} \
  --moving-mask ${tmpdir}/$((n - 1))/mnimask.mnc \
  ${tmpdir}/${n}/denoise.mnc ${REGISTRATIONMODEL} ${tmpdir}/${n}/mni

antsRegistration_affine_SyN.sh --clobber --verbose --histogram-matching \
  --linear-type lsq9 \
  --skip-nonlinear \
  --fixed-mask ${REGISTRATIONBRAINMASK} \
  --moving-mask ${tmpdir}/$((n - 1))/mnimask.mnc \
  ${tmpdir}/${n}/denoise.mnc ${REGISTRATIONMODEL} ${tmpdir}/${n}/mni_lsq9

# LSQ12 resample
antsApplyTransforms -d 3 --verbose -i ${tmpdir}/${n}/denoise.mnc -r ${RESAMPLEMODEL} \
  ${MNI_XFM:+-t ${MNI_XFM}} \
  -t ${tmpdir}/${n}/mni0_GenericAffine.xfm -n BSpline[5] -o ${tmpdir}/${n}/mni.mnc

antsApplyTransforms -d 3 --verbose -i ${tmpdir}/$((n - 1))/mnimask.mnc -r ${RESAMPLEMODEL} \
  ${MNI_XFM:+-t ${MNI_XFM}} \
  -t ${tmpdir}/${n}/mni0_GenericAffine.xfm -n GenericLabel -o ${tmpdir}/${n}/mnimask_in_mni.mnc

# LSQ9 resample
antsApplyTransforms -d 3 --verbose -i ${tmpdir}/${n}/denoise.mnc -r ${RESAMPLEMODEL} \
  ${MNI_XFM:+-t ${MNI_XFM}} \
  -t ${tmpdir}/${n}/mni_lsq90_GenericAffine.xfm -n BSpline[5] -o ${tmpdir}/${n}/mni_lsq9.mnc

antsApplyTransforms -d 3 --verbose -i ${tmpdir}/$((n - 1))/mnimask.mnc -r ${RESAMPLEMODEL} \
  ${MNI_XFM:+-t ${MNI_XFM}} \
  -t ${tmpdir}/${n}/mni_lsq90_GenericAffine.xfm -n GenericLabel -o ${tmpdir}/${n}/mnimask_in_mni_lsq9.mnc

# Shrink the mask a bit to try to exclude non-brain tissue
iMath 3 ${tmpdir}/${n}/mnimask_in_mni.mnc ME ${tmpdir}/${n}/mnimask_in_mni.mnc 2 1 ball 1
iMath 3 ${tmpdir}/${n}/mnimask_in_mni_lsq9.mnc ME ${tmpdir}/${n}/mnimask_in_mni_lsq9.mnc 2 1 ball 1

mincmath -clamp -const2 0 65535 ${tmpdir}/${n}/mni.mnc ${tmpdir}/${n}/mni.clamp.mnc
mv -f ${tmpdir}/${n}/mni.clamp.mnc ${tmpdir}/${n}/mni.mnc

mincmath -clamp -const2 0 65535 ${tmpdir}/${n}/mni_lsq9.mnc ${tmpdir}/${n}/mni_lsq9.clamp.mnc
mv -f ${tmpdir}/${n}/mni_lsq9.clamp.mnc ${tmpdir}/${n}/mni_lsq9.mnc

volume_pol --order 1 --min 0 --max 100 --noclamp ${tmpdir}/${n}/mni.mnc ${RESAMPLEMODEL} \
  --source_mask ${tmpdir}/${n}/mnimask_in_mni.mnc --target_mask ${RESAMPLEMASK} --clobber ${tmpdir}/${n}/mni.norm.mnc

volume_pol --order 1 --min 0 --max 100 --noclamp ${tmpdir}/${n}/mni_lsq9.mnc ${RESAMPLEMODEL} \
  --source_mask ${tmpdir}/${n}/mnimask_in_mni_lsq9.mnc --target_mask ${RESAMPLEMASK} --clobber ${tmpdir}/${n}/mni_lsq9.norm.mnc

mincbeast -verbose -fill -median -same_res -flip -v2 -conf ${BEASTLIBRARY_DIR}/default.1mm.conf ${BEASTLIBRARY_DIR} \
  ${tmpdir}/${n}/mni.norm.mnc ${tmpdir}/${n}/beastmask.mnc

mincbeast -verbose -fill -median -same_res -flip -v2 -conf ${BEASTLIBRARY_DIR}/default.1mm.conf ${BEASTLIBRARY_DIR} \
  ${tmpdir}/${n}/mni_lsq9.norm.mnc ${tmpdir}/${n}/beastmask_lsq9.mnc

antsApplyTransforms -d 3 -i ${tmpdir}/${n}/beastmask.mnc -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] \
  ${MNI_XFM:+-t [ ${MNI_XFM},1 ]} \
  -n GenericLabel --verbose \
  -r ${tmpdir}/input.mnc -o ${tmpdir}/bmask.mnc

antsApplyTransforms -d 3 -i ${tmpdir}/${n}/beastmask_lsq9.mnc -t [ ${tmpdir}/${n}/mni_lsq90_GenericAffine.xfm,1 ] \
  ${MNI_XFM:+-t [ ${MNI_XFM},1 ]} \
  -n GenericLabel --verbose \
  -r ${tmpdir}/input.mnc -o ${tmpdir}/bmask_lsq9.mnc

ImageMath 3 ${tmpdir}/mergedmask.mnc MajorityVoting ${tmpdir}/$((n - 1))/mnimask.mnc ${tmpdir}/bmask.mnc ${tmpdir}/bmask_lsq9.mnc

antsRegistration_affine_SyN.sh --clobber --verbose \
  --histogram-matching \
  ${_arg_fast_nlin} \
  --close \
  --initial-transform ${tmpdir}/${n}/mni0_GenericAffine.xfm \
  --fixed-mask ${REGISTRATIONBRAINMASK} --moving-mask ${tmpdir}/mergedmask.mnc \
  ${tmpdir}/${n}/denoise.mnc ${REGISTRATIONMODEL} ${tmpdir}/${n}/mni

antsApplyTransforms -d 3 -i ${WMPRIOR} -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -t ${tmpdir}/${n}/mni1_inverse_NL.xfm \
  -n Linear --verbose \
  -r ${tmpdir}/input.mnc -o ${tmpdir}/${n}/prior3.mnc
antsApplyTransforms -d 3 -i ${GMPRIOR} -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -t ${tmpdir}/${n}/mni1_inverse_NL.xfm \
  -n Linear --verbose \
  -r ${tmpdir}/input.mnc -o ${tmpdir}/${n}/prior2.mnc
antsApplyTransforms -d 3 -i ${CSFPRIOR} -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -t ${tmpdir}/${n}/mni1_inverse_NL.xfm \
  -n Linear --verbose \
  -r ${tmpdir}/input.mnc -o ${tmpdir}/${n}/prior1.mnc

if [[ -s ${DEEPGMPRIOR:-} ]]; then
  antsApplyTransforms -d 3 -i ${DEEPGMPRIOR} -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -t ${tmpdir}/${n}/mni1_inverse_NL.xfm \
    -n Linear --verbose \
    -r ${tmpdir}/input.mnc -o ${tmpdir}/${n}/prior4.mnc
fi

antsApplyTransforms -d 3 -i ${REGISTRATIONBRAINMASK} -t [ ${tmpdir}/${n}/mni0_GenericAffine.xfm,1 ] -t ${tmpdir}/${n}/mni1_inverse_NL.xfm \
  -n GenericLabel --verbose \
  -r ${tmpdir}/input.mnc -o ${tmpdir}/${n}/nlin_mnimask.mnc

cp -f ${tmpdir}/${n}/nlin_mnimask.mnc ${tmpdir}/nlin_mnimask.mnc

ImageMath 3 ${tmpdir}/mergedmask.mnc MajorityVoting ${tmpdir}/${n}/nlin_mnimask.mnc ${tmpdir}/bmask.mnc ${tmpdir}/bmask_lsq9.mnc

ImageMath 3 ${tmpdir}/${n}/atropos_mask.mnc m ${tmpdir}/mergedmask.mnc ${tmpdir}/vessels.mnc
ImageMath 3 ${tmpdir}/${n}/atropos_mask.mnc m ${tmpdir}/${n}/atropos_mask.mnc ${tmpdir}/$((n - 1))/hotmask.mnc

if [[ -n ${DEEPGMPRIOR:-} ]]; then
  Atropos --verbose -d 3 -a ${tmpdir}/${n}/denoise.mnc -x ${tmpdir}/${n}/atropos_mask.mnc -c [ 25, 0.005 ] \
    -m [ 0.1,1x1x1 ] --posterior-formulation Aristotle[ 0 ] -s 1x2 -s 2x3 -s 1x3 -s 1x4 -s 3x4 \
    -l [ 0.69314718055994530942,1 ] \
    -i PriorProbabilityImages[ 4,${tmpdir}/${n}/prior%d.mnc,0.25 ] -o [ ${tmpdir}/${n}/classify.mnc,${tmpdir}/${n}/posterior%d.mnc ] \
    --winsorize-outliers BoxPlot
else
  Atropos --verbose -d 3 -a ${tmpdir}/${n}/denoise.mnc -x ${tmpdir}/${n}/atropos_mask.mnc -c [ 25, 0.005 ] \
    -m [ 0.1,1x1x1 ] --posterior-formulation Aristotle[ 0 ] -s 1x2 -s 2x3 -s 1x3 \
    -l [ 0.69314718055994530942,1 ] \
    -i PriorProbabilityImages[ 3,${tmpdir}/${n}/prior%d.mnc,0.25 ] -o [ ${tmpdir}/${n}/classify.mnc,${tmpdir}/${n}/posterior%d.mnc ] \
    --winsorize-outliers BoxPlot
fi

classify_to_mask

ImageMath 3 ${tmpdir}/mergedmask.mnc MajorityVoting ${tmpdir}/${n}/nlin_mnimask.mnc ${tmpdir}/classifymask.mnc ${tmpdir}/bmask.mnc ${tmpdir}/bmask_lsq9.mnc

for file in ${tmpdir}/${n}/posterior?.mnc ${tmpdir}/${n}/classify.mnc; do
  ImageMath 3 ${file} m ${file} ${tmpdir}/mergedmask.mnc
done

ThresholdImage 3 ${tmpdir}/${n}/classify.mnc ${tmpdir}/${n}/weight.mnc 2 Inf 1 0
iMath 3 ${tmpdir}/${n}/weight.mnc ME ${tmpdir}/${n}/weight.mnc 1 1 ball 1
ImageMath 3 ${tmpdir}/${n}/weight.mnc GetLargestComponent ${tmpdir}/${n}/weight.mnc
iMath 3 ${tmpdir}/${n}/weight.mnc MD ${tmpdir}/${n}/weight.mnc 1 1 ball 1

ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/vessels.mnc
make_outlier_map ${tmpdir}/${n}/denoise.mnc ${tmpdir}/fgmask.mnc ${tmpdir}/${n}/hotmask.mnc
ImageMath 3 ${tmpdir}/${n}/weight.mnc m ${tmpdir}/${n}/weight.mnc ${tmpdir}/${n}/hotmask.mnc

#Last round we do a higher-resolution N3
_arg_isostep=$(calc "${_arg_isostep} / 2")

n3input=${tmpdir}/${n}/denoise.mnc

do_N3

iMath 3 ${tmpdir}/${n}/correct_mask.mnc MD ${tmpdir}/mergedmask.mnc 2 1 ball 1
ImageMath 3 ${tmpdir}/${n}/correct_mask.mnc FillHoles ${tmpdir}/${n}/correct_mask.mnc

mincmath -clobber -unsigned -double -mult ${tmpdir}/${n}/*field.mnc ${tmpdir}/${n}/field_combined.mnc

correct_field ${tmpdir}/${n}/field_combined.mnc ${tmpdir}/${n}/correct_mask.mnc ${tmpdir}/${n}/field_combined_correct.mnc
mincmath -clobber -clamp -const2 0.1 1.79769e+308 ${tmpdir}/${n}/field_combined_correct.mnc ${tmpdir}/${n}/field_combined_correct_clamp.mnc

mincmath -clobber -unsigned -double -mult ${tmpdir}/$((n - 1))/field_combined_correct_clamp.mnc \
  ${tmpdir}/${n}/field_combined_correct_clamp.mnc ${tmpdir}/${n}/field_combined_correct_clamp2.mnc
mv -f ${tmpdir}/${n}/field_combined_correct_clamp2.mnc ${tmpdir}/${n}/field_combined_correct_clamp.mnc

origmean=$(mincstats -mean -quiet -mask ${tmpdir}/${n}/weight.mnc -mask_binvalue 1 ${tmpdir}/input.mnc)
biasmean=$(mincstats -mean -quiet -mask ${tmpdir}/${n}/weight.mnc -mask_binvalue 1 ${tmpdir}/${n}/field_combined_correct_clamp.mnc)

if [[ ${_arg_standalone} == "on" ]]; then
  minccalc -unsigned -short -expression "clamp((A[0]/${origmean})/(A[1]/${biasmean})*32767,0,65535)" \
    ${tmpdir}/input.mnc ${tmpdir}/${n}/field_combined_correct_clamp.mnc ${tmpdir}/${n}/correct.mnc -clobber

  cp -f ${tmpdir}/${n}/correct.mnc ${tmpdir}/corrected.mnc

  minc_anlm --clobber --mt $(nproc) ${tmpdir}/corrected.mnc ${tmpdir}/denoise_corrected.mnc

  ImageMath 3 ${tmpdir}/${n}/atropos_mask.mnc m ${tmpdir}/mergedmask.mnc ${tmpdir}/vessels.mnc
  ImageMath 3 ${tmpdir}/${n}/atropos_mask.mnc m ${tmpdir}/${n}/atropos_mask.mnc ${tmpdir}/$((n - 1))/hotmask.mnc

  if [[ -n ${DEEPGMPRIOR:-} ]]; then
    Atropos --verbose -d 3 -a ${tmpdir}/denoise_corrected.mnc -x ${tmpdir}/${n}/atropos_mask.mnc -c [ 25, 0.005 ] \
      -m [ 0.1,1x1x1 ] --posterior-formulation Aristotle[ 1 ] -s 1x2 -s 2x3 -s 1x3 -s 1x4 -s 3x4 \
      -l [ 0.69314718055994530942,1 ] \
      -i PriorProbabilityImages[ 4,${tmpdir}/${n}/posterior%d.mnc,0.25 ] \
      -o [ ${tmpdir}/${n}/classify.mnc,${tmpdir}/${n}/posterior%d.mnc ] \
      --winsorize-outliers BoxPlot
  else
    Atropos --verbose -d 3 -a ${tmpdir}/denoise_corrected.mnc -x ${tmpdir}/${n}/atropos_mask.mnc -c [ 25, 0.005 ] \
      -m [ 0.1,1x1x1 ] --posterior-formulation Aristotle[ 1 ] -s 1x2 -s 2x3 -s 1x3 \
      -l [ 0.69314718055994530942,1 ] \
      -i PriorProbabilityImages[ 3,${tmpdir}/${n}/posterior%d.mnc,0.25 ] \
      -o [ ${tmpdir}/${n}/classify.mnc,${tmpdir}/${n}/posterior%d.mnc ] \
      --winsorize-outliers BoxPlot
  fi

  classify_to_mask

  ImageMath 3 ${tmpdir}/mergedmask.mnc MajorityVoting ${tmpdir}/${n}/nlin_mnimask.mnc ${tmpdir}/classifymask.mnc ${tmpdir}/bmask.mnc ${tmpdir}/bmask_lsq9.mnc

  for file in ${tmpdir}/${n}/posterior?.mnc ${tmpdir}/${n}/classify.mnc; do
    ImageMath 3 ${file} m ${file} ${tmpdir}/mergedmask.mnc
  done

  # Disabled polynomial intensity stretching implementation
  # valuelow=$(mincstats -quiet -floor 1 -pctT 0.1 ${tmpdir}/corrected.mnc)
  # valuewm=$(mincstats -quiet -median -mask ${tmpdir}/${n}/classify2.mnc -mask_binvalue 3 ${tmpdir}/corrected.mnc)
  # valuegm=$(mincstats -quiet -median -mask ${tmpdir}/${n}/classify2.mnc -mask_binvalue 2 ${tmpdir}/corrected.mnc)
  # valuehigh=$(mincstats -quiet -floor 1 -pctT 99.9 ${tmpdir}/corrected.mnc)
  # mapping=($(python -c "import numpy as np; print(np.array2string(np.linalg.solve(np.array([[1, ${valuelow}, ${valuelow}**2], [1, ((${valuewm}+${valuegm})/2.0), ((${valuewm}+${valuegm})/2.0)**2], [1, ${valuehigh}, ${valuehigh}**2]]),np.array([0,32767,65535])),separator= ' ')[1:-1])"))

  # Calculate ICV, referenced to model
  mincmath -not ${REGISTRATIONBRAINMASK} ${tmpdir}/${n}/model_antimask.mnc
  mincmath -not ${tmpdir}/mergedmask.mnc ${tmpdir}/${n}/antimask.mnc
  antsRegistration_affine_SyN.sh --clobber --verbose --histogram-matching \
    --skip-nonlinear \
    --fixed-mask ${tmpdir}/${n}/model_antimask.mnc \
    --moving-mask ${tmpdir}/${n}/antimask.mnc \
    ${tmpdir}/denoise_corrected.mnc ${REGISTRATIONMODEL} ${tmpdir}/${n}/icv

  # Re-pad final image using model FOV mask
  volpad -noauto -distance 50 ${tmpdir}/corrected.mnc ${tmpdir}/corrected_pad.mnc
  mv -f ${tmpdir}/corrected_pad.mnc ${tmpdir}/corrected.mnc

  antsApplyTransforms -d 3 --verbose -i ${tmpdir}/fgmask_fov.mnc -n GenericLabel \
    -o ${tmpdir}/fgmask_fov.mnc \
    -r ${tmpdir}/corrected.mnc

  ImageMath 3 ${tmpdir}/corrected.mnc m ${tmpdir}/corrected.mnc ${tmpdir}/fgmask_fov.mnc
  ExtractRegionFromImageByMask 3 ${tmpdir}/corrected.mnc ${tmpdir}/repad.mnc ${tmpdir}/fgmask_fov.mnc 1 $(calc "int(10.0*4.0/${shrink})")
  cp -f ${tmpdir}/repad.mnc ${tmpdir}/corrected.mnc
  minc_anlm --clobber --mt $(nproc) ${tmpdir}/corrected.mnc ${tmpdir}/denoise_corrected.mnc
  mincresample -clobber -unsigned -short -tfm_input_sampling -transform ${tmpdir}/transform_to_input.xfm ${tmpdir}/corrected.mnc ${_arg_output}
  mincresample -clobber -unsigned -short -tfm_input_sampling -transform ${tmpdir}/transform_to_input.xfm ${tmpdir}/corrected.mnc $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).denoise.mnc

  # minccalc -clobber -quiet ${N4_VERBOSE:+-verbose} -short -unsigned \
  #     -expression "clamp(A[0]^2*${mapping[2]} + A[0]*${mapping[1]} + ${mapping[0]},0,65535)" \
  #     ${tmpdir}/corrected.mnc ${tmpdir}/rescale.mnc

  # mincresample -clobber -tfm_input_sampling -transform ${tmpdir}/transform_to_input.xfm ${tmpdir}/rescale.mnc \
  #     $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).rescale.mnc

  mincresample -clobber -like ${_arg_output} -transform ${tmpdir}/transform_to_input.xfm -keep -near -unsigned -byte -labels ${tmpdir}/bmask.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).beastmaskmask.mnc
  mincresample -clobber -like ${_arg_output} -transform ${tmpdir}/transform_to_input.xfm -keep -near -unsigned -byte -labels ${tmpdir}/nlin_mnimask.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlinmask.mnc
  mincresample -clobber -like ${_arg_output} -transform ${tmpdir}/transform_to_input.xfm -keep -near -unsigned -byte -labels ${tmpdir}/classifymask.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).classifymask.mnc
  mincresample -clobber -like ${_arg_output} -transform ${tmpdir}/transform_to_input.xfm -keep -near -unsigned -byte -labels ${tmpdir}/mergedmask.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).mergedmask.mnc
  mincresample -clobber -like ${_arg_output} -transform ${tmpdir}/transform_to_input.xfm -keep -near -unsigned -byte -labels ${tmpdir}/bmask.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).beastmask.mnc
  mincresample -clobber -like ${_arg_output} -transform ${tmpdir}/transform_to_input.xfm -keep -near -unsigned -byte -labels ${tmpdir}/bmask_lsq9.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).beastmask_lsq9.mnc
  mincresample -clobber -like ${_arg_output} -transform ${tmpdir}/transform_to_input.xfm -keep -near -unsigned -byte -labels ${tmpdir}/${n}/classify.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).classify.mnc

  # Resample to output the posterior probabilities from classification
  for file in ${tmpdir}/${n}/posterior?.mnc; do
    mincresample -clobber -like ${_arg_output} -transform ${tmpdir}/transform_to_input.xfm -keep -unsigned -float ${file} \
      $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).$(basename ${file})
  done

  make_qc

  xfmconcat ${tmpdir}/${n}/mni0_GenericAffine.xfm ${tmpdir}/transform_to_input.xfm $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).affine_to_model.xfm
  cp -f ${tmpdir}/${n}/icv0_GenericAffine.xfm $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).ICV.xfm
  if [[ ${_arg_save_nlin} == "on" ]]; then
    cp -f ${tmpdir}/3/mni1_NL.xfm $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_to_model.xfm
    cp -f ${tmpdir}/3/mni1_inverse_NL.xfm $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_from_model.xfm
    cp -f ${tmpdir}/3/mni1_NL_grid_0.mnc $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_to_model_grid_0.mnc
    cp -f ${tmpdir}/3/mni1_inverse_NL_grid_0.mnc $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_from_model_grid_0.mnc
    sed -i "s/mni1_NL_grid_0.mnc/$(basename ${_arg_output} .mnc).nlin_to_model_grid_0.mnc/g" $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_to_model.xfm
    sed -i "s/mni1_inverse_NL_grid_0.mnc/$(basename ${_arg_output} .mnc).nlin_from_model_grid_0.mnc/g" $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_from_model.xfm
  fi

  if [[ "${_arg_lsq6_resample_type}" != "none" ]]; then
    # Create LSQ6 version of affine transform
    xfminvert ${tmpdir}/${n}/mni0_GenericAffine.xfm ${tmpdir}/mni0_GenericAffine_invert.xfm
    param2xfm $(xfm2param ${tmpdir}/mni0_GenericAffine_invert.xfm | grep -E 'scale|shear') ${tmpdir}/scaleshear.xfm
    xfminvert ${tmpdir}/scaleshear.xfm ${tmpdir}/unscaleshear.xfm
    xfmconcat ${tmpdir}/mni0_GenericAffine_invert.xfm ${tmpdir}/unscaleshear.xfm ${tmpdir}/lsq6.xfm

    if [[ ${_arg_lsq6_resample_type} == "coordinates" ]]; then
      mincresample -clobber -unsigned -short -tfm_input_sampling -transform ${tmpdir}/lsq6.xfm ${tmpdir}/corrected.mnc \
        $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mnc
    else
      ResampleImage 3 ${RESAMPLEMODEL} ${tmpdir}/resamplemodel.mnc ${_arg_lsq6_resample_type}x${_arg_lsq6_resample_type}x${_arg_lsq6_resample_type} 0
      mincresample -clobber -unsigned -short -like ${tmpdir}/resamplemodel.mnc -transform ${tmpdir}/lsq6.xfm ${tmpdir}/corrected.mnc \
        $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mnc
    fi

    cp -f ${tmpdir}/lsq6.xfm $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.xfm
    mincresample -clobber -transform ${tmpdir}/lsq6.xfm -like $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mnc \
      -keep -near -unsigned -byte -labels ${tmpdir}/mergedmask.mnc $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mergedmask.mnc
    mincresample -clobber -transform ${tmpdir}/lsq6.xfm -like $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mnc \
      -keep -near -unsigned -byte -labels ${tmpdir}/${n}/classify2.mnc $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.classify.mnc
  fi
else
  mincresample -fillvalue 1 -like ${tmpdir}/originput.mnc ${tmpdir}/${n}/field_combined_correct_clamp.mnc \
    ${tmpdir}/${n}/field_combined_correct_clamp_orig.mnc
  minccalc -expression "A[0]/(A[1]/${biasmean})" ${tmpdir}/originput.mnc \
    ${tmpdir}/${n}/field_combined_correct_clamp_orig.mnc ${tmpdir}/backtransform.mnc
  mincresample -clobber -tfm_input_sampling -transform ${tmpdir}/transform_to_input.xfm ${tmpdir}/backtransform.mnc ${_arg_output}
fi

# ] <-- needed because of Argbash
